This is a backported version of a 2.6.32 patch with the following description:
 
commit 721d67cdca5b7642b380ca0584de8dceecf6102f
Author: Roland Dreier <rolandd@cisco.com>
Date:   Sat Sep 5 20:23:40 2009 -0700

    IPoIB: Drop priv->lock before calling ipoib_send()

    IPoIB currently must use irqsave locking for priv->lock, since it is
    taken from interrupt context in one path.  However, ipoib_send() does
    skb_orphan(), and the network stack locking is not IRQ-safe.
    Therefore we need to make sure we don't hold priv->lock when calling
    ipoib_send() to avoid lockdep warnings (the code was almost certainly
    safe in practice, since the only code path that takes priv->lock from
    interrupt context would never call into the network stack).

    Addresses: http://bugzilla.kernel.org/show_bug.cgi?id=13757
    Reported-by: Bart Van Assche <bart.vanassche@gmail.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

---

diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index e319d91..2bf5116 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -604,8 +604,11 @@ static void neigh_add_path(struct sk_buff *skb, struct net_device *dev)
 					   skb_queue_len(&neigh->queue));
 				goto err_drop;
 			}
-		} else
+		} else {
+			spin_unlock_irqrestore(&priv->lock, flags);
 			ipoib_send(dev, skb, path->ah, IPOIB_QPN(skb->dst->neighbour->ha));
+			return;
+		}
 	} else {
 		neigh->ah  = NULL;
 
@@ -688,7 +691,9 @@ static void unicast_arp_send(struct sk_buff *skb, struct net_device *dev,
 		ipoib_dbg(priv, "Send unicast ARP to %04x\n",
 			  be16_to_cpu(path->pathrec.dlid));
 
+		spin_unlock_irqrestore(&priv->lock, flags);
 		ipoib_send(dev, skb, path->ah, IPOIB_QPN(phdr->hwaddr));
+		return;
 	} else if ((path->query || !path_rec_start(dev, path)) &&
 		   skb_queue_len(&path->queue) < IPOIB_MAX_PATH_REC_QUEUE) {
 		/* put pseudoheader back on for next time */
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
index a0e9753..a0825fe 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
@@ -720,7 +720,9 @@ out:
 			}
 		}
 
+		spin_unlock_irqrestore(&priv->lock, flags);
 		ipoib_send(dev, skb, mcast->ah, IB_MULTICAST_QPN);
+		return;
 	}
 
 unlock:
