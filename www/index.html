<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta name="Keywords" content="Generic SCSI Target Subsystem for Linux, SCST, SCSI target">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="author" content="Daniel Fernandes">
<meta name="Robots" content="index,follow">
<meta name="verify-v1" content="N5TwpSXr8cNkQf0gvE3F3sv+TPHL15k4dTo+ZQCeV9Q=">
<link rel="stylesheet" href="images/Orange.css" type="text/css">	
<title>SCST: A Generic SCSI Target Subsystem for Linux</title>
</head>

<body>
<div id="wrap"> 
	<div id="header">	
		<div class="logoimg"></div><h1 id="logo"><span class="orange"></span></h1>
		<h2 id="slogan">Generic SCSI Target Subsystem for Linux</h2>	
	</div>
	<div id="menu">
		<ul>
			<li id="current"><a href="index.html">Home</a></li>
			<li><a href="http://www.sourceforge.net/projects/scst">Main/News</a></li>
			<li><a href="targets.html">Drivers</a></li>
			<li><a href="downloads.html">Downloads</a></li>
			<li><a href="contributing.html">Contributing</a></li>
			<li><a href="comparison.html">Comparison</a></li>			
			<li><a href="solutions.html">Solutions</a></li>
		</ul>
	</div>	
	<div id="content-wrap">
	  		<div id="main">
				<h1>Generic SCSI Target Subsystem for Linux</h1>
						
				<p>The <strong>generic SCSI target subsystem for Linux (SCST)</strong> is an alternative
					implementation of a SCSI target subsystem for Linux. It provides unified,
					consistent interface between SCSI target drivers and 
					Linux kernel as well as between Linux kernel and storage backend
					handlers, connecting target drivers with real or emulated storage backend.
					
				<p>SCST allows creation of sophisticated storage devices, which  provide advanced 
					functionality, like <strong>replication</strong>, <strong>thin provisioning</strong>,
					<strong>deduplication</strong>, <strong>high availability</strong>,
					<strong>automatic backup</strong>, etc. Another class of such devices
					are <strong>Virtual Tape Libraries</strong> (VTL)
					as well as other disk-based backup solutions. SCST created devices not
					limited by IP networking only. They can use any link which supports
					SCSI-style data exchange, including <strong>Fibre Channel</strong>,
					<strong>iSCSI</strong>, <strong>SAS</strong>,
					<strong>InfiniBand</strong> and <strong>parallel (Wide) SCSI</strong>. It might
					well be that your favorite storage appliance running SCST in the firmware.</p>

				<p>SCST project consists from a set of subprojects: <strong>generic SCSI target mid-layer itself (SCST core)</strong>
					with a set of <strong>device handlers</strong> as well as <strong>target drivers</strong>
					and <strong>user space utilities</strong>.
				
				<h1>Features of SCST Core</h1>
				<ul>					
					<li><span>SCST core has simple, easy to use interface with target drivers. 
								 SCST core performs all required pre- and post- processing of incoming requests as well as 
								 necessary error recovery.</span></li>
					<li><span>SCST core undertakes most problems, related to execution contexts, thus practically eliminating one of the most 
								 complicated problem in the kernel drivers development. For example, target drivers for Marvell 
								 SAS adapters or for InfiniBand SRP are less 3000 lines of code long.</span></li>
					<li><span>Very low overhead, fine-grained locks and simplest commands processing path allow to reach 
								 maximum possible performance and scalability. Particularly, incoming requests can be processed in 
								 the caller's context or in one of the internal SCST core's tasklets without any
								 extra context switches.</span></li>
					<li><span>Device handlers, i.e. plugins, architecture allows various I/O 
								 modes in backstorage handling. For example, pass-through device handlers allows to use real 
								 SCSI hardware and vdisk device handler allows to use files as virtual disks.</span></li>
					<li><span>Advanced per-initiator devices visibility management (LUN masking) allows different 
								 initiators to see different set of devices with different access permissions. For instance, 
								 initiator A could see exported from target T devices X and Y read-writable, and initiator B from 
								 the same target T could see devices Y read-only and Z read-writable.
								 This feature is required for hardware targets, which don't have ability to create
								 virtual targets (SAS adapters, for instance).</span></li>
					<li><span>SCST core emulates necessary functionality of SCSI host adapter, because from remote initiators' point of view 
								 a SCSI target acts as a SCSI host with its own devices. This is especially important in pass-through mode with 
								 one to many relationship, i.e. when multiple initiators can connect to the exported pass-through 
								 devices. You can find more deep elaboration why it is needed in <a href="http://www.mail-archive.com/linux-scsi@vger.kernel.org/msg06911.html">this</a> 
								 message in thread "Question for pass-through target design" in linux-scsi mailing list. Some of the emulated functions are the following:
								 <ul>
									<li><span>Generation of necessary UNIT ATTENTIONs, their storage and delivery to all connected 
												 remote initiators.</span></li>								 

									<li><span>RESERVE/RELEASE functionality.</span></li>

									<li><span>All types of RESETs and other task management functions.</span></li>

									<li><span>REPORT LUNS command as well as SCSI address space management in order to have consistent 
												 address space on all remote initiators, since local SCSI devices could not know about each
												 other to report via REPORT LUNS command. Additionally, SCST core responds with error on all 
												 commands to non-existing devices and provides access control, so different remote 
												 initiators could see different set of devices.</span></li>

									<li><span>Other necessary functionality (task attributes, etc.) as specified in SAM-2, SPC-2, SAM-3,
												 SPC-3 and other SCSI standards.</span></li>
								 </ul>
								 </span></li>

					<li><span>SCST core has multithreaded design and complete SMP support, so, if necessary, all your CPU cores will participate in the commands
								 processing.</span></li>
					<li><span>Well documented.</span></li>							
				</ul>					
				<p>Interoperability between remote and local SCSI initiators (i.e. sd, st, etc.) is the additional issue that SCST is going to 
				address (it is not implemented yet). It is necessary, because local SCSI initiators can change the state of the 
				device, for example RESERVE the device, or some of its parameters and that could be done behind SCST, i.e. remote initiators
				will not know about it, which could 
				lead to various problems, including data corruption. Thus, RESERVE/RELEASE commands, locally generated 
				UNIT ATTENTIONs, etc. should be intercepted and passed through SCST core.</p>			
					
				<h1>SCST core supports the following I/O modes</h1>
				<ul>
					<li><span><strong>Pass-through mode</strong> with one to many relationship, i.e. when multiple initiators can 
						connect to the exported pass-through devices, for virtually all SCSI devices types: <strong>disks (type 0), 
						tapes (type 1), processors (type 3), CDROMs (type 5), MO disks (type 7), medium changers (type 8) and RAID 
						controllers (type 0xC)</strong>. In this mode you can, for instance, share your parallel SCSI tape or SATA
						DVD-RW device to your iSCSI network.</span></li>
    				<li><span><strong>FILEIO mode</strong>, which allows to use files on file systems or block devices as virtual 
    					remotely available SCSI disks or CDROMs with benefits of the Linux <strong>cache</strong>.</span></li>
    				<li><span><strong>BLOCKIO mode</strong>, which performs direct block IO with a block device, bypassing 
    					page-cache for all operations. This mode works well with high-end storage HBAs and for applications that 
    					either do not need caching between application and disk or need the large block throughput.</span></li>
    				<li><span><strong>User space mode</strong> using scst_user device handler, which allows to implement in the 
    					user space virtual SCSI devices in the SCST environment.</span></li>
    				<li><span><strong>"Performance" device handlers</strong> as well as <strong>NULLIO</strong> mode provide
    					a way for direct performance measurements without overhead of actual data
    				        transferring from/to underlying SCSI device.
    					</span></li>
				</ul>			
	  		</div>
			<div id="rightbar">
				<h1>Documentation</h1>
				<p><a href="scst_pg.html">HTML</a></p>
				<p><a href="scst_pg.pdf">PDF</a></p>
				<p><a href="iscsi-scst-howto.txt">HOWTO For iSCSI-SCST</a></p>
				<p><a href="qla2x00t-howto.html">HOWTO For QLogic Target Driver</a></p>
				<p><a href="http://lpfcxxxx.sourceforge.net/HOWTO.lpfc">HOWTO For Emulex lpfc Target Driver</a></p>
				<p><a href="scst_user_spec.txt">SCST User Interface Description</a></p>
				<p><a href="sgv_cache.txt">SCST SGV Cache Description</a></p>
				<h1>SCST 0.9.6 graphs</h1>
				<p><a href="images/init_scst.png">init_scst</a></p>
				<p><a href="images/scst_cmd_thread.png">scst_cmd_thread</a></p>				
				<p><a href="images/scst_mgmt_cmd_thread.png">scst_mgmt_cmd_thread</a></p>
				<p><a href="images/scst_mgmt_thread.png">scst_mgmt_thread</a></p>
				<p>by Ming Zhang</p>
				<h1>QUESTIONS</h1>
				<p>If you have any questions you can ask them via<br><a href="https://lists.sourceforge.net/lists/listinfo/scst-devel">
					scst-devel mailing list</a><br><br> 
					See <a href="http://sourceforge.net/mail/?group_id=110471">mailing lists page</a> for more info about SCST mailing 
					lists.</p>
				<h1>SourceForge</h1>
				<p><a href="http://sourceforge.net">
					<img src="http://sourceforge.net/sflogo.php?group_id=110471&amp;type=2" alt="SourceForge.net Logo" border="0">
					</a></p>		
			</div>
	</div>
</div>		
<!-- footer starts here -->		
		<div id="footer">
			<p>
			&copy; Copyright 2004-2009 <b><font color="#EC981F">Vladislav Bolkhovitin &amp others.</font>&nbsp;&nbsp;
			Design by: <b><font color="#EC981F">Daniel Fernandes</font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		
			
			</p>		
		</div>	
<!-- footer ends here -->
</body>

<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://apps.sourceforge.net/piwik/scst/" : "http://apps.sourceforge.net/piwik/scst/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
piwik_action_name = '';
piwik_idsite = 1;
piwik_url = pkBaseURL + "piwik.php";
piwik_log(piwik_action_name, piwik_idsite, piwik_url);
</script>
<object><noscript><p><img src="http://apps.sourceforge.net/piwik/scst/piwik.php?idsite=1" alt="piwik"/></p></noscript></object>
<!-- End Piwik Tag -->

</html>
