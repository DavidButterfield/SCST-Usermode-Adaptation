--- /home/dave/orig/scst/iscsi-scst/usr/event.c	2016-03-27 10:24:59.000000000 -0600
+++ scst/iscsi-scst/usr/event.c	2017-03-18 10:57:32.481216734 -0600
@@ -1066,6 +1066,14 @@
 			goto retry;
 		log_error("read netlink fd (%d) failed: %s", fd, strerror(errno));
 		exit(1);
+	} else if (rc == 0) {
+		/* EOF on nl_fd --
+		 * We arrive here after the kernel module closes the other end
+		 * of nl_fd during shutdown of the kernel modules.  The daemon
+		 * thread is expected to exit when this happens.
+		 */
+		log_info("kernel module shutdown -- daemon exits");
+		exit(1);
 	}
 
 	log_debug(1, "target %u, session %#" PRIx64 ", conn %u, code %u, cookie %d",
--- /home/dave/orig/scst/iscsi-scst/usr/target.c	2016-07-01 19:42:49.000000000 -0600
+++ scst/iscsi-scst/usr/target.c	2017-03-18 10:57:32.481216734 -0600
@@ -415,7 +415,7 @@
 	}
 
 	memset(target, 0, sizeof(*target));
-	memcpy(target->name, name, sizeof(target->name) - 1);
+	strncpy(target->name, name, sizeof(target->name) - 1);
 
 	params_set_defaults(target->target_params, target_keys);
 	params_set_defaults(target->session_params, session_keys);
--- /home/dave/orig/scst/iscsi-scst/usr/iscsi_scstd.c	2016-03-27 10:24:59.000000000 -0600
+++ scst/iscsi-scst/usr/iscsi_scstd.c	2017-03-18 10:57:32.481216734 -0600
@@ -232,14 +232,15 @@
 
 	iser_fd = create_and_open_dev("isert_scst", 1);
 
-	poll_array[POLL_ISER_LISTEN].fd = iser_fd;
-	if (iser_fd != -1) {
+	if (iser_fd >= 0) {
+		poll_array[POLL_ISER_LISTEN].fd = iser_fd;
 		poll_array[POLL_ISER_LISTEN].events = POLLIN;
 
 		/* RDMAExtensions */
 		session_keys[key_rdma_extensions].max = 1;
 		session_keys[key_rdma_extensions].local_def = 1;
 	} else {
+		poll_array[POLL_ISER_LISTEN].fd = -1;
 		poll_array[POLL_ISER_LISTEN].events = 0;
 		return;
 	}
@@ -508,8 +509,11 @@
 	case IOSTATE_READ_BHS:
 	case IOSTATE_READ_AHS_DATA:
 	      read_again:
+		errno = 0;	/* for the log_debug() */
 		res = read(pollfd->fd, conn->buffer, conn->rwsize);
 		if (res <= 0) {
+			log_debug(1, "read(%u, %p, %u) returned %d, errno=%u",
+			      pollfd->fd, conn->buffer, conn->rwsize, res, errno);
 			if (res == 0 || (errno != EINTR && errno != EAGAIN)) {
 				conn->state = STATE_DROP;
 				goto out;
@@ -576,6 +580,8 @@
 		conn->cork_transmit(pollfd->fd);
 		res = write(pollfd->fd, conn->buffer, conn->rwsize);
 		if (res < 0) {
+			log_debug(1, "write(%u, %p, %u) returned %d, errno=%u",
+			      pollfd->fd, conn->buffer, conn->rwsize, res, errno);
 			if (errno != EINTR && errno != EAGAIN) {
 				conn->state = STATE_DROP;
 				goto out;
@@ -746,7 +752,8 @@
 			    (conn->state == STATE_DROP)) {
 				struct session *sess = conn->sess;
 
-				log_debug(1, "closing conn %p", conn);
+				log_debug(1, "closing conn %p state=0x%x fd=%u",
+					  conn, conn->state, pollfd->fd);
 				conn_free_pdu(conn);
 				close(pollfd->fd);
 				pollfd->fd = -1;
@@ -839,8 +846,13 @@
 	/*
 	 * Otherwise we could die in some later write() during the event_loop()
 	 * instead of getting EPIPE!
+	 *
+	 * The effects of signal(2) in a multithreaded process are unspecified,
+	 * so use sigaction(2) instead.
 	 */
-	signal(SIGPIPE, SIG_IGN);
+	struct sigaction act = (struct sigaction) { .sa_handler = SIG_IGN };
+	int rc = sigaction(SIGPIPE, &act, NULL);
+	assert(rc == 0);
 
 	while ((ch = getopt_long(argc, argv, "c:fd:s:u:g:a:p:vh", long_options, &longindex)) >= 0) {
 		switch (ch) {
--- /home/dave/orig/scst/iscsi-scst/usr/config.c	2016-03-27 10:24:59.000000000 -0600
+++ scst/iscsi-scst/usr/config.c	2017-03-18 10:57:32.481216734 -0600
@@ -856,11 +856,12 @@
 
 	if (type == key_session) {
 		for (i = 0; i < session_key_last; i++) {
+			uint32_t in_val = params[i].val;
 			if (partial & (1 << i)) {
 				err = params_check_val(session_keys, i, &params[i].val);
 				if (err < 0) {
-					log_error("Wrong value %u for parameter %s\n",
-						params[i].val, session_keys[i].name);
+					log_error("%s: Wrong value %u->%u for session parameter %s\n",
+						__func__, in_val, params[i].val, session_keys[i].name);
 					goto out;
 				}
 			}
@@ -871,11 +872,12 @@
 		}
 	} else {
 		for (i = 0; i < target_key_last; i++) {
+			uint32_t in_val = params[i].val;
 			if (partial & (1 << i)) {
 				err = params_check_val(target_keys, i, &params[i].val);
 				if (err < 0) {
-					log_error("Wrong value %u for parameter %s\n",
-						params[i].val, target_keys[i].name);
+					log_error("%s: Wrong value %u->%u for target parameter %s\n",
+						__func__, in_val, params[i].val, target_keys[i].name);
 					goto out;
 				}
 			}
@@ -962,10 +964,11 @@
 				continue;
 			}
 
+			uint32_t in_val = val;
 			res = params_check_val(target_keys, idx, &val);
 			if (res < 0) {
-				log_error("Wrong value %u for parameter %s\n",
-					val, target_keys[idx].name);
+				log_error("%s: Wrong value %u->%u for target parameter %s\n",
+					  __func__, in_val, val, target_keys[idx].name);
 				continue;
 			}
 			target->target_params[idx] = val;
@@ -986,10 +989,11 @@
 				continue;
 			}
 
+			uint32_t in_val = val;
 			res = params_check_val(session_keys, idx, &val);
 			if (res < 0) {
-				log_error("Wrong value %u for parameter %s\n",
-					val, session_keys[idx].name);
+				log_error("%s: Wrong value %u->%u for session parameter %s\n",
+					  __func__, in_val, val, session_keys[idx].name);
 				continue;
 			}
 			target->session_params[idx] = val;
--- /home/dave/orig/scst/iscsi-scst/usr/chap.c	2016-03-27 10:24:59.000000000 -0600
+++ scst/iscsi-scst/usr/chap.c	2017-03-18 10:57:32.481216734 -0600
@@ -105,6 +105,9 @@
 		else if ((base64 >= '0') && (base64 <= '9'))
 			return 52 + (base64 - '0');
 		else
+			//XXX This return value should be unsigned; and anyway
+			//XXX in case of a bad character in the string, our
+			//XXX caller (sometimes) checks for 65, not 255 or -1
 			return -1;
 	}
 }
@@ -146,6 +149,8 @@
 	num[1] = decode_base64_digit(string[count + 1]);
 	num[2] = decode_base64_digit(string[count + 2]);
 	num[3] = decode_base64_digit(string[count + 3]);
+	//XXX Check for the special "bad character in string" value here like above?
+	//XXX Also check the string for missing/incorrect padding?
 	if ((num[0] == 64) || (num[1] == 64))
 		return;
 	if (num[2] == 64) {
@@ -196,6 +201,7 @@
 	octets = 0;
 	strptr = 0;
 
+	//XXX warning: cannot optimize loop, the loop counter may overflow [-Wunsafe-loop-optimizations]
 	while ((delta = (length - count)) > 2) {
 		octets = (intnum[count] << 16) | (intnum[count + 1] << 8) | intnum[count + 2];
 		string[strptr] = base64code[(octets & 0xfc0000) >> 18];
--- /home/dave/orig/scst/iscsi-scst/kernel/iscsi.c	2016-12-19 23:00:43.000000000 -0700
+++ scst/iscsi-scst/kernel/iscsi.c	2017-03-18 10:57:32.485216807 -0600
@@ -234,7 +234,11 @@
 
 	cmnd->scst_state = ISCSI_CMD_STATE_RESTARTED;
 
+#ifdef CONFIG_SCST_TEST_IO_IN_SIRQ	//XXXX OK?
+	scst_restart_cmd(cmnd->scst_cmd, status, SCST_CONTEXT_DIRECT);
+#else
 	scst_restart_cmd(cmnd->scst_cmd, status, SCST_CONTEXT_THREAD);
+#endif
 
 out:
 	TRACE_EXIT();
@@ -509,6 +513,8 @@
 			if (cmnd->sg != &dummy_sg)
 				scst_free_sg(cmnd->sg, cmnd->sg_cnt);
 #ifdef CONFIG_SCST_DEBUG
+			//XXX What if a BUG makes correct behavior depend on this?
+			//XXX The bug will disappear whenever you enable debugging!
 			cmnd->own_sg = 0;
 			cmnd->sg = NULL;
 			cmnd->sg_cnt = -1;
@@ -2149,6 +2155,7 @@
 	req->scst_state = ISCSI_CMD_STATE_RX_CMD;
 	conn->rx_task = current;
 	scst_cmd_init_stage1_done(scst_cmd, SCST_CONTEXT_DIRECT, 0);
+	conn->rx_task = NULL;       //XXX Right?
 
 	if (req->scst_state != ISCSI_CMD_STATE_RX_CMD)
 		res = req->conn->transport->iscsit_receive_cmnd_data(req);
@@ -4232,7 +4239,7 @@
 	if (p == NULL) {
 		PRINT_ERROR("Unable to allocate iSCSI thread pool (size %zd)",
 			sizeof(*p));
-		res = -ENOMEM;
+		res = -ENOMEM;	    //XXX superfluous
 		if (!list_empty(&iscsi_thread_pools_list)) {
 			PRINT_WARNING("%s", "Using global iSCSI thread pool "
 				"instead");
--- /home/dave/orig/scst/iscsi-scst/kernel/nthread.c	2016-10-26 15:33:50.000000000 -0600
+++ scst/iscsi-scst/kernel/nthread.c	2017-03-18 10:57:32.485216807 -0600
@@ -599,7 +599,7 @@
 	close_conn(conn);
 
 	TRACE_EXIT();
-	return 0;
+	do_exit(0);	    //XXX Right?  No one does kthread_stop() on this one
 }
 
 /* No locks */
--- /home/dave/orig/scst/iscsi-scst/kernel/conn.c	2016-12-19 22:53:48.000000000 -0700
+++ scst/iscsi-scst/kernel/conn.c	2017-03-18 10:57:32.485216807 -0600
@@ -397,7 +397,7 @@
 	 */
 	list_for_each_entry_reverse(conn, &session->conn_list,
 					conn_list_entry) {
-		if (conn->cid == cid)
+		if (conn->cid == cid && !conn->closing) //XXXX Right?
 			return conn;
 	}
 	return NULL;
@@ -1126,7 +1126,8 @@
 			local_bh_enable();
 		pr_emerg("rd_state %x\n", conn->rd_state);
 		pr_emerg("rd_task %p\n", conn->rd_task);
-		pr_emerg("rd_task->pid %d\n", conn->rd_task->pid);
+		if (conn->rd_task)
+		    pr_emerg("rd_task->pid %d\n", conn->rd_task->pid);
 		BUG();
 	}
 }
--- /home/dave/orig/scst/iscsi-scst/kernel/session.c	2016-12-19 23:00:43.000000000 -0700
+++ scst/iscsi-scst/kernel/session.c	2017-03-18 10:57:32.485216807 -0600
@@ -65,7 +65,7 @@
 
 #ifdef CONFIG_SCST_PROC
 	name = kmalloc(strlen(info->user_name) + strlen(info->initiator_name) +
-			1, GFP_KERNEL);
+			2, GFP_KERNEL);	// +1 (for '\0') +1 (for '@')  XXX Right?
 	if (name == NULL) {
 		err = -ENOMEM;
 		goto err;
@@ -100,7 +100,7 @@
 
 	if (!session->sess_params.rdma_extensions) {
 		err = iscsi_threads_pool_get(
-			(bool)scst_get_acg_tgt_priv(session->scst_sess->acg),
+			scst_get_acg_tgt_priv(session->scst_sess->acg) != NULL,
 			&session->scst_sess->acg->acg_cpu_mask,
 			&session->sess_thr_pool);
 		if (err != 0)
--- /home/dave/orig/scst/usr/stpgd/stpgd_main.c	2016-02-23 18:01:54.000000000 -0700
+++ scst/usr/stpgd/stpgd_main.c	2017-03-18 10:57:32.485216807 -0600
@@ -195,7 +195,7 @@
 			}
 			break;
 		}
-		sleep(0.1);
+		usleep(100*1000);
 		time(&end);
 		elapsed = difftime(end, start);
 	} while (elapsed < deadline);
--- /home/dave/orig/scst/Makefile	2017-01-23 17:29:41.000000000 -0700
+++ scst/Makefile	2017-03-18 10:57:32.485216807 -0600
@@ -196,7 +196,7 @@
 	@if [ -d $(EMULEX_DIR) ]; then cd $(EMULEX_DIR) && $(MAKE) $@; fi
 
 extraclean:
-	-rm -f TAGS
+	-rm -f TAGS tags cscope.out
 	cd $(SCST_DIR) && $(MAKE) $@
 	@if [ -d $(DOC_DIR) ]; then cd $(DOC_DIR) && $(MAKE) $@; fi
 	@if [ -d $(QLA_INI_DIR) ]; then cd $(QLA_INI_DIR) && $(MAKE) $@; fi
--- /home/dave/orig/scst/scst/include/scst.h	2017-03-01 08:31:59.000000000 -0700
+++ scst/scst/include/scst.h	2017-03-18 10:57:32.489216880 -0600
@@ -4081,6 +4081,7 @@
 	else if (in_atomic())
 		return SCST_CONTEXT_DIRECT_ATOMIC;
 	else
+		//XXX Isn't this backwards?  Could it explain "non-reliability"?
 		return atomic ? SCST_CONTEXT_DIRECT :
 				SCST_CONTEXT_DIRECT_ATOMIC;
 #else
--- /home/dave/orig/scst/scst/include/backport.h	2016-12-19 22:55:19.000000000 -0700
+++ scst/scst/include/backport.h	2017-03-18 10:57:32.489216880 -0600
@@ -76,6 +76,11 @@
  * 230fa253df6352af12ad0a16128760b5cb3f92df).
  */
 #define READ_ONCE(x) (*(volatile typeof(x) *)&(x))
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#define ACCESS_ONCE(x) READ_ONCE(x)
+#endif
+
 #endif
 
 /* <linux/cpumask.h> */
--- /home/dave/orig/scst/scst/src/scst_pres.c	2016-07-25 20:04:34.000000000 -0600
+++ scst/scst/src/scst_pres.c	2017-03-18 10:57:32.489216880 -0600
@@ -2659,6 +2659,7 @@
 		b[6] = 0;
 		b[7] = 0x10;
 
+		//XXX warning: dereferencing type-punned pointer will break strict-aliasing rules
 		put_unaligned(key, (__be64 *)&b[8]);
 		b[21] = dev->pr_scope << 4 | dev->pr_type;
 
--- /home/dave/orig/scst/scst/src/scst_no_dlm.c	2016-01-21 21:04:43.000000000 -0700
+++ scst/scst/src/scst_no_dlm.c	2017-03-18 10:57:32.489216880 -0600
@@ -63,7 +63,7 @@
 
 static bool scst_no_dlm_reserved(struct scst_device *dev)
 {
-	return dev->reserved_by;
+	return (dev->reserved_by != NULL);
 }
 
 static void scst_no_dlm_res_lock(struct scst_device *dev,
--- /home/dave/orig/scst/scst/src/scst_main.c	2017-03-01 17:09:14.000000000 -0700
+++ scst/scst/src/scst_main.c	2017-03-18 10:57:32.489216880 -0600
@@ -2859,7 +2859,9 @@
 	scsi_unregister_interface(&scst_interface);
 
 #ifdef CONFIG_SCST_PROC
+	mutex_lock(&scst_mutex);	//XXX Right?
 	scst_del_free_acg(scst_default_acg, false);
+	mutex_unlock(&scst_mutex);
 #endif
 
 	scst_sgv_pools_deinit();
--- /home/dave/orig/scst/scst/src/dev_handlers/scst_vdisk.c	2017-03-01 08:31:59.000000000 -0700
+++ scst/scst/src/dev_handlers/scst_vdisk.c	2017-03-18 10:57:32.489216880 -0600
@@ -83,6 +83,7 @@
 #define SCST_FIO_VENDOR			"SCST_FIO"
 #define SCST_BIO_VENDOR			"SCST_BIO"
 /* 4 byte ASCII Product Revision Level - left aligned */
+	   //XXX Is SCST_FIO_REV really "left aligned" here?
 #define SCST_FIO_REV			" 330"
 
 #define MAX_USN_LEN			(20+1) /* For '\0' */
@@ -137,7 +138,7 @@
 
 #define DEF_DPICZ		SCST_DPICZ_CHECK_ON_xPROT_0
 
-#define DEF_DIF_FILENAME_TMPL	(SCST_VAR_DIR "/dif_tags/%s.dif")
+#define DEF_DIF_FILENAME_TMPL	SCST_VAR_DIR "/dif_tags/%s.dif"
 
 #ifdef CONFIG_SCST_PROC
 #define VDISK_PROC_HELP		"help"
@@ -1158,6 +1159,8 @@
 	} else if (S_ISBLK(inode->i_mode)) {
 		inode = inode->i_bdev->bd_inode;
 	} else {
+		PRINT_ERROR("File %s smells bad: mode=0%o\n",
+			    filename, inode->i_mode);
 		res = -EINVAL;
 		goto out_close;
 	}
@@ -1698,6 +1701,11 @@
 
 	dev->dev_rd_only = virt_dev->rd_only;
 
+	//XXX Is this right?  Should it be under #ifdef CONFIG_SCST_PROC?
+	if (virt_dev->nullio && !virt_dev->file_size) {
+	    virt_dev->file_size = VDISK_NULLIO_SIZE;
+	}
+
 	res = vdisk_reexamine(virt_dev);
 	if (res < 0)
 		goto out;
@@ -2078,7 +2086,12 @@
 			res = err;
 			goto out_set_fs;
 		} else if (err < full_len) {
-			/*
+			/* If a write() is interrupted by a signal handler before
+			 * any bytes are written, then the call fails with the
+			 * error EINTR; if it is interrupted after at least one
+			 * byte has been written, the call succeeds, and returns
+			 * the number of bytes written  --  manpage write(2)
+			 *
 			 * Probably that's wrong, but sometimes write() returns
 			 * value less, than requested. Let's restart.
 			 */
@@ -8115,6 +8128,7 @@
 		} else if (!strcasecmp("blocksize", p)) {
 			virt_dev->blk_shift = scst_calc_block_shift(val);
 			if (virt_dev->blk_shift < 9) {
+				PRINT_ERROR("blocksize %u too small", 1<<virt_dev->blk_shift);
 				res = -EINVAL;
 				goto out;
 			}
@@ -10358,6 +10372,7 @@
 
 			block_shift = scst_calc_block_shift(block_size);
 			if (block_shift < 9) {
+				PRINT_ERROR("blocksize %u too small", 1<<block_shift);
 				res = -EINVAL;
 				goto out_free_vdev;
 			}
@@ -10425,7 +10440,7 @@
 			PRINT_ERROR("File path \"%s\" is not "
 				"absolute", filename);
 			res = -EINVAL;
-			goto out_up;
+			goto out_free_vdev;	//XXX Right?
 		}
 
 		virt_dev->filename = kstrdup(filename, GFP_KERNEL);
--- /home/dave/orig/scst/scst/src/scst_proc.c	2016-03-27 10:56:50.000000000 -0600
+++ scst/scst/src/scst_proc.c	2017-03-18 10:57:32.493216953 -0600
@@ -939,23 +939,14 @@
 /* The activity supposed to be suspended and scst_mutex held */
 static int scst_proc_group_add(const char *p, unsigned int addr_method)
 {
-	int res = 0, len = strlen(p) + 1;
+	int res = 0;
 	struct scst_acg *acg;
-	char *name = NULL;
-
 	TRACE_ENTRY();
 
-	name = kmalloc(len, GFP_KERNEL);
-	if (name == NULL) {
-		PRINT_ERROR("Allocation of new name (size %d) failed", len);
-		goto out_nomem;
-	}
-	strlcpy(name, p, len);
-
-	res = scst_alloc_add_acg(NULL, name, false, &acg);
+	res = scst_alloc_add_acg(NULL, p, false, &acg);
 	if (res != 0) {
-		PRINT_ERROR("scst_alloc_add_acg() (name %s) failed", name);
-		goto out_free;
+		PRINT_ERROR("scst_alloc_add_acg() (name %s) failed", p);
+		goto out;
 	}
 
 	acg->addr_method = addr_method;
@@ -971,11 +962,6 @@
 out_free_acg:
 	scst_proc_del_free_acg(acg, 0);
 
-out_free:
-	kfree(name);
-	goto out;
-
-out_nomem:
 	res = -ENOMEM;
 	goto out;
 }
@@ -1227,7 +1213,12 @@
 
 	/* We may not bother about locks here */
 	scst_proc_cleanup_sgv();
+
+	//XXX the lockdep_assert_held() in scst_del_free_acg disagrees with the comment above
+	mutex_lock(&scst_mutex);
 	scst_proc_cleanup_groups();
+	mutex_unlock(&scst_mutex);
+
 	scst_proc_cleanup_module_log();
 	remove_proc_entry(SCST_PROC_THREADS_NAME, scst_proc_scsi_tgt);
 	remove_proc_entry(SCST_PROC_HELP_NAME, scst_proc_scsi_tgt);
--- /home/dave/orig/scst/scst/src/scst_tg.c	2016-04-20 20:19:25.000000000 -0600
+++ scst/scst/src/scst_tg.c	2017-03-18 10:57:32.493216953 -0600
@@ -1296,7 +1296,7 @@
 	res = -EEXIST;
 	if (__lookup_dg_by_name(name))
 		goto out_unlock;
-	res = -ENOMEM;
+	res = -ENOMEM;	//XXX superfluous
 	INIT_LIST_HEAD(&dg->dev_list);
 	INIT_LIST_HEAD(&dg->tg_list);
 	res = scst_dg_sysfs_add(parent, dg);
--- /home/dave/orig/scst/scst/src/scst_targ.c	2017-03-01 17:10:24.000000000 -0700
+++ scst/scst/src/scst_targ.c	2017-03-18 10:57:32.493216953 -0600
@@ -1552,6 +1552,7 @@
 		else if (r == 0) {
 			if (unlikely(cmd->bufflen == 0)) {
 				/* See comment in scst_alloc_space() */
+				//XXX There is no comment in scst_alloc_space()
 				if (cmd->sg == NULL)
 					goto alloc;
 			}
@@ -5588,7 +5589,8 @@
 			sBUG();
 		}
 #endif
-		TRACE_DBG("Adding cmd %p to head of active cmd list", cmd);
+		TRACE_DBG("Adding cmd %p state %u to head of active cmd list",
+			  cmd, cmd->state);
 
 		spin_lock_irq(&cmd->cmd_threads->cmd_list_lock);
 		list_add(&cmd->cmd_list_entry,
@@ -5638,11 +5640,12 @@
 {
 	struct scst_cmd_thread_t *thr = arg;
 	struct scst_cmd_threads *p_cmd_threads = thr->thr_cmd_threads;
-	bool someth_done, p_locked, thr_locked;
+	bool someth_done;
 
 	TRACE_ENTRY();
 
-	TRACE(TRACE_MINOR, "Processing thread %s started", current->comm);
+	TRACE(TRACE_MINOR, "Processing thread %s @ %p started on tid=%d",
+			   current->comm, current, current->pid);
 
 #if 0
 	set_user_nice(current, 10);
@@ -5653,6 +5656,8 @@
 
 	wake_up_all(&p_cmd_threads->ioctx_wq);
 
+	/* Hold both locks for the test_cmd_threads() checks */
+	/* Lock acquisition order is always:  First p_cmd_threads, Then thr */
 	spin_lock_irq(&p_cmd_threads->cmd_list_lock);
 	spin_lock(&thr->thr_cmd_list_lock);
 	while (!kthread_should_stop()) {
@@ -5674,10 +5679,12 @@
 			finish_wait(&p_cmd_threads->cmd_list_waitQ, &wait);
 		}
 
+		/* Drop both locks now that we are through the test_cmd_threads() checks */
+		spin_unlock(&thr->thr_cmd_list_lock);
+		spin_unlock_irq(&p_cmd_threads->cmd_list_lock);
+
 		if (tm_dbg_is_release()) {
-			spin_unlock_irq(&p_cmd_threads->cmd_list_lock);
 			tm_dbg_check_released_cmds();
-			spin_lock_irq(&p_cmd_threads->cmd_list_lock);
 		}
 
 		/*
@@ -5689,42 +5696,29 @@
 		 * reaching this point here.
 		 */
 
-		p_locked = true;
-		thr_locked = true;
 		do {
 			int thr_cnt;
-
+			struct scst_cmd *cmd;
 			someth_done = false;
-again:
-			if (!list_empty(&p_cmd_threads->active_cmd_list)) {
-				struct scst_cmd *cmd;
-
-				if (!p_locked) {
-					if (thr_locked) {
-						spin_unlock_irq(&thr->thr_cmd_list_lock);
-						thr_locked = false;
-					}
-					spin_lock_irq(&p_cmd_threads->cmd_list_lock);
-					p_locked = true;
-					goto again;
-				}
 
-				cmd = list_first_entry(&p_cmd_threads->active_cmd_list,
-							typeof(*cmd), cmd_list_entry);
+			for (thr_cnt = 0; thr_cnt < 1; thr_cnt++) {
+				cmd = NULL;
+				spin_lock_irq(&p_cmd_threads->cmd_list_lock);
 
-				TRACE_DBG("Deleting cmd %p from active cmd list", cmd);
-				list_del(&cmd->cmd_list_entry);
+				if (!list_empty(&p_cmd_threads->active_cmd_list)) {
+					cmd = list_first_entry(&p_cmd_threads->active_cmd_list,
+								typeof(*cmd), cmd_list_entry);
 
-				if (thr_locked) {
-					spin_unlock(&thr->thr_cmd_list_lock);
-					thr_locked = false;
+					TRACE_DBG("Deleting cmd %p from active cmd list", cmd);
+					list_del(&cmd->cmd_list_entry);
 				}
+
 				spin_unlock_irq(&p_cmd_threads->cmd_list_lock);
-				p_locked = false;
+
+				if (!cmd) break;
 
 				if (cmd->cmd_thr == NULL) {
-					TRACE_DBG("Assigning thread %p on cmd %p",
-						thr, cmd);
+					TRACE_DBG("Assigning thread %p on cmd %p", thr, cmd);
 					cmd->cmd_thr = thr;
 				}
 
@@ -5732,52 +5726,29 @@
 				someth_done = true;
 			}
 
-			if (thr_locked && p_locked) {
-				/* We need to maintain order of locks and unlocks */
-				spin_unlock(&thr->thr_cmd_list_lock);
-				spin_unlock(&p_cmd_threads->cmd_list_lock);
+			for (thr_cnt = 0; thr_cnt < 2; thr_cnt++) {
+				cmd = NULL;
+
 				spin_lock(&thr->thr_cmd_list_lock);
-				p_locked = false;
-			} else if (!thr_locked) {
-				if (p_locked) {
-					spin_unlock_irq(&p_cmd_threads->cmd_list_lock);
-					p_locked = false;
-				}
-				spin_lock_irq(&thr->thr_cmd_list_lock);
-				thr_locked = true;
-			}
 
-			thr_cnt = 0;
-			while (!list_empty(&thr->thr_active_cmd_list)) {
-				struct scst_cmd *cmd = list_first_entry(
-							&thr->thr_active_cmd_list,
-							typeof(*cmd), cmd_list_entry);
+				if (!list_empty(&thr->thr_active_cmd_list)) {
+					cmd = list_first_entry(&thr->thr_active_cmd_list,
+							       typeof(*cmd), cmd_list_entry);
+
+					TRACE_DBG("Deleting cmd %p from thr active cmd list", cmd);
+					list_del(&cmd->cmd_list_entry);
+				}
 
-				TRACE_DBG("Deleting cmd %p from thr active cmd list", cmd);
-				list_del(&cmd->cmd_list_entry);
+				spin_unlock(&thr->thr_cmd_list_lock);
 
-				spin_unlock_irq(&thr->thr_cmd_list_lock);
-				thr_locked = false;
+				if (!cmd) break;
 
 				scst_process_active_cmd(cmd, false);
 
 				someth_done = true;
-
-				if (++thr_cnt == 2)
-					break;
-				else {
-					spin_lock_irq(&thr->thr_cmd_list_lock);
-					thr_locked = true;
-				}
 			}
-		} while (someth_done);
 
-		EXTRACHECKS_BUG_ON(p_locked);
-
-		if (thr_locked) {
-			spin_unlock_irq(&thr->thr_cmd_list_lock);
-			thr_locked = false;
-		}
+		} while (someth_done);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 		if (scst_poll_ns > 0) {
@@ -5821,7 +5792,8 @@
 
 	scst_ioctx_put(p_cmd_threads);
 
-	TRACE(TRACE_MINOR, "Processing thread %s finished", current->comm);
+	TRACE(TRACE_MINOR, "Processing thread %s @ %p finished on tid=%d",
+			   current->comm, current, current->pid);
 
 	TRACE_EXIT();
 	return 0;
--- /home/dave/orig/scst/scst/src/scst_copy_mgr.c	2017-03-01 08:31:59.000000000 -0700
+++ scst/scst/src/scst_copy_mgr.c	2017-03-18 10:57:32.493216953 -0600
@@ -193,8 +193,13 @@
 
 static void scst_cm_retry_work_fn(struct work_struct *work)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	struct scst_cm_retry *retry = container_of(work, struct scst_cm_retry,
+						   cm_retry_work);  //XXX Right?
+#else
 	struct scst_cm_retry *retry = container_of(work, struct scst_cm_retry,
 						   cm_retry_work.work);
+#endif
 
 	TRACE_ENTRY();
 
@@ -309,7 +314,11 @@
 	if (imm_retry) {
 		/* Let's use work to avoid possible recursion */
 		TRACE_DBG("Immediate retry (cmd %p)", cmd);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+		schedule_work(&retry->cm_retry_work);	    //XXX Right?
+#else
 		schedule_work(&retry->cm_retry_work.work);
+#endif
 	} else {
 		TRACE_DBG("Scheduling cmd %p retry", cmd);
 		schedule_delayed_work(&retry->cm_retry_work,
--- /home/dave/orig/scst/scst/src/scst_lib.c	2017-03-07 21:43:23.000000000 -0700
+++ scst/scst/src/scst_lib.c	2017-03-18 10:59:36.759490841 -0600
@@ -4430,6 +4430,7 @@
 		acg_dev->acg_dev_dif_guard_format = SCST_DIF_GUARD_FORMAT_CRC;
 	} else
 		acg_dev->acg_dev_dif_guard_format =
+		    acg->tgt &&	    /* sometimes NULL */
 			acg->tgt->tgt_hw_dif_ip_supported && !dev->dev_dif_ip_not_supported ?
 							SCST_DIF_GUARD_FORMAT_IP :
 							SCST_DIF_GUARD_FORMAT_CRC;
@@ -4696,8 +4697,13 @@
 				 acg_dev_list_entry)
 		scst_del_acg_dev(acg_dev, true);
 
+#ifndef SCST_7105   //XXXXXXX DAB merge conflict
 	list_for_each_entry(acn, &acg->acn_list, acn_list_entry)
 		scst_acn_sysfs_del(acn);
+#else
+ 	list_for_each_entry_safe(acn, acnt, &acg->acn_list, acn_list_entry)
+		scst_del_free_acn(acn, false);	    //XXXX Right?
+#endif
 
 #ifdef CONFIG_SCST_PROC
 	list_del(&acg->acg_list_entry);
@@ -7693,6 +7699,8 @@
 			if (bio_data_dir(bio) == READ && err == 0) {
 				unsigned long flags;
 
+				//XXX What's a KM?  Need lock?  (Or maybe a little more comment)
+				//XXX Or OK for the irq to run concurrently on a different CPU?
 				local_irq_save(flags);	/* to protect KMs */
 				sg_copy(bw->src_sgl, bw->sg_table.sgl, 0, 0
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
@@ -14570,6 +14578,7 @@
 		DECLARE_WAIT_QUEUE_HEAD_ONSTACK(w);
 
 		b->ext_blocker_done_fn = scst_sync_ext_blocking_done;
+		//XXX warning: dereferencing type-punned pointer will break strict-aliasing rules
 		*((void **)&b->ext_blocker_data[0]) = &w;
 
 		wait_event_locked(w, (dev->on_dev_cmd_count == 0),
