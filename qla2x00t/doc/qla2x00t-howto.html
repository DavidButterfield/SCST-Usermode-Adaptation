<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>
How to configure QLogic target driver for 22xx/23xx/24xx/25xx adapters
</title>
<style type="text/css">
pre {color:brown;}
body > ol > li {padding-bottom:1ex;}
</style>
<body>

<div style="text-align: center;"> <strong>How to configure QLogic target driver for 22xx/23xx/24xx/25xx adapters. Step by step guide.</strong><br><br></div>

                    <div style="text-align: center;"> <strong>ON TARGET</strong></div><br><br>

<ol>
<li>
   Download the appropriate firmware for your QLogic card from <a href="http://ldriver.qlogic.com/firmware/">
   http://ldriver.qlogic.com/firmware/</a> and save it in the /lib/firmware directory.
   It is strongly recommended to use firmware version 5.x or higher for
   24xx/25xx adapters. More information about this subject can be found in
   the following thread on the scst-devel mailing list:
   <a href="http://sourceforge.net/mailarchive/forum.php?thread_name=4B4CD39F.6020401%40vlnb.net&amp;forum_name=scst-devel">FC
   session gets closed with qla2x00t</a>.

   <br><br>

   If no firmware image is available when the QLogic kernel module is loaded,
   the following error message will appear in the kernel log
   (/var/log/messages):

<pre>qla2xxx 0000:13:00.0: Firmware image unavailable.
qla2xxx 0000:13:00.0: Failed to initialize adapter</pre>

   In this case I had to download ql2500_fw.bin.
</li>

<li>Install the necessary kernel development packages. On a Debian system
these packages can be installed as follows:
<pre>[root@proj ]# apt-get install gcc libncurses5-dev linux-headers-`uname -r` lsscsi patch subversion</pre>
On RHEL/CentOS/SL systems these packages can be installed as follows:
<pre>[root@proj ]# yum install gcc ncurses-devel kernel-devel lsscsi patch subversion</pre>
And on SUSE systems these packages can be installed by running the following command:
<pre>[root@proj ]# zypper install gcc ncurses-devel kernel-devel lsscsi patch subversion</pre>
</li>

<li>
  Download the SCST source code. That source code can be downloaded either
  from the <a href="http://scst.sourceforge.net/downloads.html">SCST
  downloads page</a> or from the SCST Subversion source code
  repository.<br><br>
    
  In what follows it is assumed that the SCST trunk has been retrieved
  via Subversion. Installing a released SCST version is identical to
  installing the trunk after all downloaded SCST source code archives have
  been extracted in a single directory. The structure of that directory will
  be identical to that of the SCST trunk.
    
<pre>[root@proj ]# svn co https://svn.code.sf.net/p/scst/svn/trunk scst</pre>

  After the above command finished a directory called 'scst' will have been
  created in the current directory, which is /root in this how-to.
</li>

<li>
Find out whether you will need SCSI pass-through and/or the iSCSI
zero-copy optimization. If not, skip the kernel download, patch, rebuild
and reboot steps and continue with the <a href="#release">SCST build step</a>.
</li>

<li>Decide whether you want to start from a vanilla Linux kernel source tree
or from the kernel source tree specific to your Linux distribution. Vanilla kernel sources can be downloaded from <a href="http://www.kernel.org/pub/linux/kernel/">http://www.kernel.org/pub/linux/kernel/</a>. Unzip the downloaded archive under /usr/src:
<pre>[root@proj ]# cd /usr/src
[root@proj src ]# tar -xjf /usr/src/linux-3.11.8.tar.bz2</pre>
Instructions for obtaining a distribution-specific kernel source tree vary. An example for Debian:
<pre>[root@proj src ]# apt-get install linux-source-`uname -r`
[root@proj src ]# tar xjf linux-source-`uname -r`.tar.bz2</pre>
</li>

<li>
  Patch the kernel that has just been downloaded:
<pre>[root@proj src ]# ln -s linux-3.11 linux
[root@proj src ]# cd linux
[root@proj linux ]# patch -p1 &lt /root/scst/scst/kernel/scst_exec_req_fifo-3.11.patch</pre>
</li>

<li>The next step is to configure the kernel:
<pre>[root@proj linux ]# pwd
/usr/src/linux
[root@proj linux ]# make menuconfig</pre>
   
  If you have built a 32-bit kernel make sure to disable HIGHMEM4G and
  HIGHMEM64G, i.e.
<pre>[root@proj linux ]# grep -i highmem .config
CONFIG_NOHIGHMEM=y
# CONFIG_HIGHMEM4G is not set
# CONFIG_HIGHMEM64G is not set</pre>
   
  If you have built a 32-bit kernel on a system with more than 1GB of memory,
  consider to change CONFIG_VMSPLIT option to an appropriate value.
</li>
<li>Next, build and install the kernel:
<pre>[root@proj linux ]# make -j$(ls -1d /sys/devices/system/cpu/cpu[0-9]* | wc -l) bzImage modules
[root@proj linux ]# make modules_install install</pre>
</li>

<li>
  Reboot the system and during boot select the freshly built kernel to boot from.
</li>

<li>
Unload the qla2xxx kernel module provided by your Linux distribution and blacklist it:
<pre>[root@proj ]# echo blacklist qla2xxx >/etc/modprobe.d/blacklist-qla2xxx.conf
[root@proj ]# rmmod qla2xxx</pre>
</li>

<li>
  OPTIONAL step: clean up the kernel modules directory before building the
  SCST kernel modules.<br> This is only necessary if you encounter the
  following error message: "scst: disagrees about version of symbol
  struct_module".<br><br>
   
  That error message indicates that a kernel module was compiled against
  kernel headers that did not match the running kernel. Doing a clean rebuild
  of the kernel and SCST should make the above error go away. To make sure
  nothing of the old kernel is left, do a clean rebuild of the Linux kernel
  and SCST as follows:
   
<pre>[root@proj linux ]# pwd
/usr/src/linux
[root@proj linux ]# make oldconfig
[root@proj linux ]# make clean
[root@proj linux ]# rm -rf /lib/modules/`uname -r`
[root@proj linux ]# make -j$(ls -1d /sys/devices/system/cpu/cpu[0-9]* | wc -l) bzImage modules
[root@proj linux ]# make modules_install install
[root@proj linux ]# reboot</pre>
</li>

<li id="release">
  Select a build mode that suits your needs, e.g. optimal performance or
  debugging SCST. The default mode is debug mode. Here is how to switch to
  release mode:
<pre>[root@proj scst ]# pwd
/root/scst
[root@proj scst ]# make 2release</pre>
</li>

<li>
  Now build the SCST kernel modules. But first verify that the link
  "/lib/modules/`uname -r`/build" points to the kernel headers of the
  currently running kernel. Build and install SCST, e.g. as follows:
<pre>[root@proj ]# cd /root/scst
[root@proj scst ]# BUILD_2X_MODULE=y CONFIG_SCSI_QLA_FC=y CONFIG_SCSI_QLA2XXX_TARGET=y make all install</pre>

  Verify that compilation and installation succeeded:
	<pre>[root@proj scst]# ls -l /lib/modules/`uname -r`/extra/qla2*
-rw-r--r--  1 root root  36756 Jun 20 18:46 qla2x00tgt.ko
-rw-r--r--  1 root root 160192 Jun 20 18:46 qla2xxx_scst.ko   
</pre>
</li>

<li>
  Insert the kernel modules.<br>  The kernel modules have been installed in
  '/lib/modules/`your_kernel_version`/extra'.<br>  In addition, scst.h,
  scst_debug.h as well as Module.symvers or Modules.symvers have been copied
  to '/usr/local/include/scst'.<br> The first file contains all SCST's public
  interfaces used by target drivers. The other files allow target drivers to
  generate debug messages and support the kernel module build process.

<pre>[root@proj scst]# ls -l /lib/modules/`uname -r`/extra
total 232
drwxr-xr-x  2 root root   4096 Jun 20 18:43 dev_handlers
-rw-r--r--  1 root root  36756 Jun 20 18:46 qla2x00tgt.ko
-rw-r--r--  1 root root 160192 Jun 20 18:46 qla2xxx_scst.ko   
-rw-r--r--  1 root root 190848 Jun 20 18:43 scst.ko

[root@proj scst]# ls -l /lib/modules/`uname -r`/extra/dev_handlers
total 192
-rw-r--r--  1 root root 11757 Jun 20 18:43 scst_cdrom.ko
-rw-r--r--  1 root root 10111 Jun 20 18:43 scst_changer.ko
-rw-r--r--  1 root root 12420 Jun 20 18:43 scst_disk.ko
-rw-r--r--  1 root root 12449 Jun 20 18:43 scst_modisk.ko
-rw-r--r--  1 root root 10131 Jun 20 18:43 scst_processor.ko
-rw-r--r--  1 root root 10081 Jun 20 18:43 scst_raid.ko
-rw-r--r--  1 root root 12563 Jun 20 18:43 scst_tape.ko
-rw-r--r--  1 root root 37937 Jun 20 18:43 scst_user.ko
-rw-r--r--  1 root root 50194 Jun 20 18:43 scst_vdisk.ko</pre>
   
where:
<ul>
<li>scst - SCST itself.</li>
<li>scst_disk - device handler for disks (type 0).</li>
<li>scst_tape - device handler for tapes (type 1).</li>
<li>scst_processor - device handler for processors (type 3).</li>
<li>scst_cdrom - device handler for CDROMs (type 5).</li>
<li>scst_modisk - device handler for MO disks (type 7).</li>
<li>scst_changer - device handler for medium changers (type 8).</li>
<li>scst_raid - device handler for storage array controller (e.g. raid) (type C).</li>
<li>scst_vdisk - device handler for virtual disks (file, device or ISO CD image)..</li>
<li>scst_user - user space device handler.</li>
</ul>
<br>

  You can insert any of these kernel modules with the 'modprobe' program. As
  you can see, I've inserted all SCST kernel modules !!!
<pre>[root@proj ]# for m in scst qla2xxx_scst qla2x00tgt scst_vdisk scst_user scst_disk ...; do modprobe $m; done</pre>

  This will result in the following dmesg output:

<pre>scst: SCST version 2.0.0 loaded successfully (max mem for commands 16251MB, per device 6500MB)
scst: Enabled features: TRACING
scst: Target template qla2x00tgt registered successfully
scst: Virtual device handler vdisk for type 0 registered successfully
scst: Virtual device handler "scst_user" registered successfully</pre>
</li>

<li>
Back up and rebuild the initial RAM disk such that the qla2xxx kernel module in
that RAM disk will be replaced by qla2xxx_scst. How to do this depends on your
Linux distribution. The initial RAM disk can be rebuilt e.g. as follows:
<pre>[root@proj ]# type update-initrd >/dev/null 2>&amp;1 &amp;&amp; update-initrd -c -k `uname -r`
[root@proj ]# type update-initramfs >/dev/null 2>&amp;1 &amp;&amp; update-initramfs -c -k `uname -r`
[root@proj ]# if type mkinitrd >/dev/null 2>&amp;1; then
if { rpm -q sles-release || rpm -q openSUSE-release; } >/dev/null 2>&amp;1;
then mkinitrd; else mkinitrd -f /boot/initramfs-`uname -r`.img `uname -r`; fi; fi</pre>
</li>

<li>
Now let's create our virtual device:

<pre>[root@proj ]# dd if=/dev/zero of=/mnt/disk1 bs=1024k count=512
512+0 records in
512+0 records out

[root@proj ]# ls -l /mnt/disk1
-rw-r--r--  1 root root 536870912 Jun 23 13:27 /mnt/disk1

[root@proj ]# file /mnt/disk1
/mnt/disk1: data</pre>
</li>

<li>The next step is to install scstadmin:
  <pre>[root@proj ]# make -C scstadmin -s install</pre>
</li>

<li id="target-mode">
  To see the device on the initiator we have to add it in the LUNs set of our
  target.<br>  We must have a LUN with number 0 (LUs numeration must not start
  from, e.g., 1).<br><br>

  The simplest way to do that is to generate an scstadmin config file, e.g. as
  follows:

<pre>modprobe qla2x00tgt
find /sys/kernel/scst_tgt/targets/qla2x00t -name enabled | \
while read f; do echo 1 >$f & done; wait
find /sys -name issue_lip | while read f; do echo 1 >$f & done; wait
{
cat &lt;&lt;EOF
HANDLER vdisk_fileio {
        DEVICE disk1 {
                filename /mnt/disk1
        }
}
EOF
for p in /sys/kernel/scst_tgt/targets/qla2x00t/*; do
[ -d $p ] || continue
cat &lt;&lt;EOF

TARGET_DRIVER qla2x00t {
        TARGET $(basename $p) {
                enabled 1

                LUN 0 disk1
        }
}
EOF
done
} >scst.conf</pre>

Check the generated config file. If it looks fine to you, move it to the
default location:
<pre>mv -i scst.conf /etc/scst.conf</pre>

The SCST configuration in that file can be applied via scstadmin:

<pre>[root@proj ]# scstadmin -config /etc/scst.conf

Collecting current configuration: done.

-> Checking configuration file 'qq' for errors.
	-> Done, 0 warnings found.
	
	-> Opening device 'disk1' using handler 'vdisk_fileio': done.
	-> Adding device 'disk1' at LUN 0 to driver/target 'qla2x00t/25:00:00:f0:98:87:92:f3': done.
	-> Enabling driver/target 'qla2x00t/25:00:00:f0:98:87:92:f3': done.
	
	All done.</pre>
	

The same can be done directly via the sysfs interface of SCST:
<pre>
[root@proj ]# echo "add_device disk1 filename=/mnt/disk1" >/sys/kernel/scst_tgt/handlers/vdisk_fileio/mgmt
[root@proj ]# echo "add disk1 0" >/sys/kernel/scst_tgt/targets/qla2x00t/25:00:00:f0:98:87:92:f3/luns/mgmt
[root@proj ]# echo "1" >/sys/kernel/scst_tgt/targets/qla2x00t/25:00:00:f0:98:87:92:f3/enabled
</pre>
</li>
<li>If you want to configure LUN masking the next step is to configure
  one initiator group per initiator. To do that you need to discover the
  initiator port WWNs. One way to discover these is as follows:
  <pre>[root@proj ]# ls -d /sys/kernel/scst_tgt/targets/qla2x00t/*/sessions/*|sed 's,.*/,,' | sort -u
10:00:00:00:c9:95:c7:1a
10:00:00:00:c9:95:c7:1b
21:00:00:24:ff:46:c0:84
21:00:00:24:ff:46:c0:85
21:00:00:24:ff:6c:ca:d8
21:00:00:24:ff:6c:ca:d9
21:00:00:24:ff:6c:ca:da
21:00:00:24:ff:6c:ca:db</pre>
  More information about initiator group configuration together with an
  example can be found in the scst.conf man page.</li>
</ol>

<br>
<div style="text-align: center;"><strong>ON INITIATOR</strong></div>
<br>

<ol>
<li>
  A quote from the SCST README:<blockquote><em> Without loading appropriate
  device handler, corresponding device will be invisible for remote
  initiators, hence we have to add them manually.</em></blockquote>  But as
  I've already loaded the device handler (scst_vdisk) on the target, I don't
  have to perform any additional steps.
</li>

<li>
  After <a href="#target-mode">enabling the target mode</a> on the target, to
  see new targets and devices on the initiator you need have to trigger a
  rescan on the initiator. That is possible either by rebooting the initiator
  or by unloading and reloading the initiator kernel module.  Automatic
  discovery isn't supported by all known initiators, so you need a way to make
  SCSI subsystem on the initiator to do the new devices discovery and hence be
  able to see the new devices attached.

  Alternatively, if your initiator already connected to the target and you
  simply added new devices to it, you can try to run a manual rescan as follows:

<pre>[root@initiator ]# echo "- - -" >/sys/class/scsi_host/hostX/scan</pre>
where X is the host number.
</li>

</ol>

</body>
</html>   		
