diff -rup linux-source-2.6.26.orig/block/blk-ioc.c linux-source-2.6.26/block/blk-ioc.c
--- linux-source-2.6.26.orig/block/blk-ioc.c	2008-07-13 17:51:29.000000000 -0400
+++ linux-source-2.6.26/block/blk-ioc.c	2009-08-26 13:31:49.000000000 -0400
@@ -65,6 +65,21 @@ static void cfq_exit(struct io_context *
 	rcu_read_unlock();
 }
 
+void __exit_io_context(struct io_context *ioc)
+{
+	if (ioc == NULL)
+		return;
+
+	if (atomic_dec_and_test(&ioc->nr_tasks)) {
+		if (ioc->aic && ioc->aic->exit)
+			ioc->aic->exit(ioc->aic);
+		cfq_exit(ioc);
+
+		put_io_context(ioc);
+	}
+}
+EXPORT_SYMBOL(__exit_io_context);
+
 /* Called by the exitting task */
 void exit_io_context(void)
 {
@@ -75,13 +90,7 @@ void exit_io_context(void)
 	current->io_context = NULL;
 	task_unlock(current);
 
-	if (atomic_dec_and_test(&ioc->nr_tasks)) {
-		if (ioc->aic && ioc->aic->exit)
-			ioc->aic->exit(ioc->aic);
-		cfq_exit(ioc);
-
-		put_io_context(ioc);
-	}
+	__exit_io_context(ioc);
 }
 
 struct io_context *alloc_io_context(gfp_t gfp_flags, int node)
@@ -106,5 +115,7 @@ struct io_context *alloc_io_context(gfp_
 	return ret;
 }
+EXPORT_SYMBOL(alloc_io_context);
+
 /*
  * If the current task has no IO context then create one and initialise it.
  * Otherwise, return its existing IO context.
diff -rup linux-source-2.6.26.orig/include/linux/iocontext.h linux-source-2.6.26/include/linux/iocontext.h
--- linux-source-2.6.26.orig/include/linux/iocontext.h	2008-07-13 17:51:29.000000000 -0400
+++ linux-source-2.6.26/include/linux/iocontext.h	2009-08-26 13:34:11.000000000 -0400
@@ -4,6 +4,8 @@
 #include <linux/radix-tree.h>
 #include <linux/rcupdate.h>
 
+#define SCST_IO_CONTEXT
+
 /*
  * This is the per-process anticipatory I/O scheduler state.
  */
@@ -99,4 +101,6 @@ static inline struct io_context *ioc_tas
 	return NULL;
 }
 
+void __exit_io_context(struct io_context *ioc);
+
 #endif
