diff -upkr linux-2.6.27.2/block/blk-ioc.c linux-2.6.27.2/block/blk-ioc.c
--- linux-2.6.27.2/block/blk-ioc.c	2008-10-10 02:13:53.000000000 +0400
+++ linux-2.6.27.2/block/blk-ioc.c	2009-03-23 21:32:37.000000000 +0300
@@ -65,6 +65,21 @@ static void cfq_exit(struct io_context *
 	rcu_read_unlock();
 }
 
+void __exit_io_context(struct io_context *ioc)
+{
+	if (ioc == NULL)
+		return;
+
+	if (atomic_dec_and_test(&ioc->nr_tasks)) {
+		if (ioc->aic && ioc->aic->exit)
+			ioc->aic->exit(ioc->aic);
+		cfq_exit(ioc);
+
+		put_io_context(ioc);
+	}
+}
+EXPORT_SYMBOL(__exit_io_context);
+
 /* Called by the exitting task */
 void exit_io_context(void)
 {
@@ -75,13 +90,7 @@ void exit_io_context(void)
 	current->io_context = NULL;
 	task_unlock(current);
 
-	if (atomic_dec_and_test(&ioc->nr_tasks)) {
-		if (ioc->aic && ioc->aic->exit)
-			ioc->aic->exit(ioc->aic);
-		cfq_exit(ioc);
-
-		put_io_context(ioc);
-	}
+	__exit_io_context(ioc);
 }
 
 struct io_context *alloc_io_context(gfp_t gfp_flags, int node)
@@ -105,6 +114,7 @@ struct io_context *alloc_io_context(gfp_
 
 	return ret;
 }
+EXPORT_SYMBOL(alloc_io_context);
 
 /*
  * If the current task has no IO context then create one and initialise it.
diff -upkr linux-2.6.27.2/include/linux/iocontext.h linux-2.6.27.2/include/linux/iocontext.h
--- linux-2.6.27.2/include/linux/iocontext.h	2008-10-10 02:13:53.000000000 +0400
+++ linux-2.6.27.2/include/linux/iocontext.h	2009-03-23 21:32:37.000000000 +0300
@@ -103,7 +103,9 @@ static inline struct io_context *ioc_tas
 int put_io_context(struct io_context *ioc);
 void exit_io_context(void);
 struct io_context *get_io_context(gfp_t gfp_flags, int node);
+#define SCST_IO_CONTEXT
 struct io_context *alloc_io_context(gfp_t gfp_flags, int node);
+void __exit_io_context(struct io_context *ioc);
 void copy_io_context(struct io_context **pdst, struct io_context **psrc);
 #else
 static inline void exit_io_context(void)
