Wed 19 Jun 2019 05:06:22 PM MDT
    This is a very early runnable version of usermode SCST/DRBD -- incomplete & probably buggy!

    The drbd source code is (nearly) unmodified, with its expected kernel environment simulated
    around it.  For more information about how that was done, see the README.md shown at
    https://github.com/DavidButterfield/SCST-Usermode-Adaptation

    Build information at the end below.

Demo config:
    I set up a small DRBD device of 1 GB, internal metadata, with ext4 filesystem

    One Node (K) running standard DRBD 9.0 in the kernel (exposing /dev/drbd1)
	DRBD's backing device is a partition on a real disk /dev/sda1
	Replicated device can be mounted as /dev/drbd1 (when primary)

    One Node (U) running DRBD 9.0 in USERMODE in a process with SCST (dev_t internal only)
	DRBD's backing device is a block device implemented as a 1 GB ramdisk
	The ramdisk is an mmap(2) backed by a 1 GB file /tmp/cfg2
	Replicated device is plumbed underneath SCST as an SCST vdisk backing bdev
	SCST exposes the volume as a SCSI device through iSCSI

    An iSCSI initiator with a session to Node (U)
	When Node U is primary, iSCSI initiator can mount the replicated filesystem
	Exposes the SCSI device as a block device, mountable as /dev/sdj (on my initiator).
	(I happened to use Node (U) also as the iSCSI initiator)

    I've written bio_tcmu to connect a bio request to a tcmu-runner storage backend handler.
    TCMU itself is not involved -- I'm just repurposing their backend handlers by translating
    bio requests from DRBD or SCST into the protocol expected by the existing TCMU handlers.

    There are several TCMU handlers for different usermode storage providers such as ceph, qemu,
    and gluster; I've written a simple one for an mmap(2) ramdisk, used here.  I also have
    started a prototype of a handler for SPDK, which interfaces into bio_tcmu from the same
    place occupied by tcmu_ram in this diagram.

                            iSCSI
  /dev/sdj ---> Initiator <=======> SCST-iSCSI 
                                        |
                                    SCST-core                                   [Node U]
                                        |        bio          bio
                                    SCST-vdisk <=====> DRBD <=====> bio_tcmu
                                                        ^               |     mmap
                                                        |           tcmu_ram <====> /tmp/cfg2
                                                        |1GbE
                                                        |
                                                        |
                                                        v     bio
                                       /dev/drbd1 ---> DRBD <=====> sda1        [Node K]

    It is also possible to plumb SCST-vdisk directly to bio_tcmu through the bio interface,
    bypassing DRBD (in that case the exposed device is unreplicated, of course).

    A sample scst.conf file below defines the following two SCST device instances, one connected
    as shown above, the other a direct connection SCST to the TCMU ram module as just mentioned.

		    initiator	SCST	        program-internal	backing file
		    ----------	-----	-------------------------------	------------
    (unreplicated)  /dev/sdi	LUN 0			/UMCdev/tcmu000	  /tmp/cfg1
    (replicated)    /dev/sdj	LUN 1	/UMCdev/drbd1	/UMCdev/tcmu001	  /tmp/cfg2

    The /tmp/cfg names are currently hardcoded in bio_tcmu.c.

Demo capabilities -- with this config I was able to do the following:
    Monitor network connection between Nodes (U) and (K) using tcpdump
    Establish DRBD replication connection between Nodes (U) and (K)
    Use Node K to create an ext4 filesystem on the replicated device
    Change primary to Node (U) and mount the replicated device on /mnt/j
    mkdir /mnt/j/git ; cd /mnt/j/git 
    Download the source repositories from github directly onto the replicated device
    Run "make" and successfully build the usermode binary on Node (U)
	while observing replication traffic in tcpdump during the build
    Lacking a mechanism to get SCST to close the DRBD device, for now I substitute this:
	Unmount /mnt/j, then kill SCST/DRBD usermode process with ^\ (SIGQUIT)
	Restart SCST/DRBD usermode process [See Limitations below]
	Re-establish network replication, but do not make Node (U) primary
    Set Node (K) as primary and mount /dev/drbd1 as /mnt/j
    Observe the built binaries from the make done on Node (U)
    Save a copy of the binary built on Node (U)
    Run "make clean" and "make all" to do the successful build again on Node (K)
	while observing replication traffic in tcpdump during the build
    Strip the two binaries and they compare equal except 20 bytes probably timestamp
    Make Node (U) primary and use scstadmin again to configure SCST
    mount /dev/sdj /mnt/j
    Copy the binary built on Node (U) onto the local disk
    Restart the server on Node (U), running the executable built on the replicated device.

    In a separate configuration I ran two usermode SCST/DRBD servers on two machines
    doing the same sort of replication as above (but not using any kernel-based DRBD).

Limitations:
    Many things are hacked just enough to get it to work, and neglecting performance.
    The Makefiles have optimizations turned off and debugs turned on.  But not taking any
    measurements, the performance seemed pretty much like normal, watching my makes run.

    Netlink multicast emulation not yet implemented, so anything like "drbdsetup wait*" hangs.

    drbdmeta assumes it can access the device through /dev/drbd*, but this is not the case on
    Node (U).  This is a problem because after a server restart drbdmeta needs to apply the
    activity log before DRBD will attach the device.

    At the moment my workaround is to destroy the metadata on Node U every time the server
    process (containing SCST and DRBD) is restarted, and let it resync from Node (K).  With my
    1 GB filesystem this takes around 25 seconds.  Before starting the server process, I tell
    drbdmeta to operate directly on the backing file for the ramdisk:

	sudo drbdmeta 1 v09 /tmp/cfg2 internal create-md 1 --force 

    Then start the usermode SCST/DRBD server:

	sudo ./scst.out -f

    On Node (U) I use drbdsetup rather than drbdadm because the latter also assumes access via
    /dev/drbd* (if nothing else at least by invoking drbdmeta):

	drbdsetup new-resource r0 0
	drbdsetup new-minor r0 1 0
	drbdsetup new-peer r0 1 --_name=bottom
	drbdsetup new-path r0 1 ipv4:192.168.1.9:7788 ipv4:192.168.1.37:7788
	drbdsetup attach 1 /UMCdev/tcmu001 /UMCdev/tcmu001 internal
	drbdsetup connect r0 1
	drbdsetup peer-device-options --resync-rate=40000 --c-plan-ahead=0 --c-min-rate=0 r0 1 0

	<wait for sync to finish>

	drbdsetup primary r0
	scstadmin -config /etc/scst.conf	    # configure SCST
	drbdsetup status --statistics --verbose

    (The "/UMCdev" names are the magic device names used internally in the usermode process)

    Something I expect NOT to work is running the server executable off of a disk it implements.

    Resync may run noticeably slower when observing resync network traffic with tcpdump.

BUGS:
    Sometimes I have trouble that resync doesn't start upon reconnect after restarting the
    usermode server.  It doesn't seem to happen as much when running tcpdump to observe the
    inter-peer traffic.  If it doesn't start, killing the usermode server with ^\ and restarting
    it has a good chance of starting the resync the second time.

    Also I sometimes have trouble running mkfs.ext4 on a replicated device, where it hangs near
    the end of the mkfs.  It always seems to work if I disconnect the secondary peer and do the
    mkfs on the primary, then reconnect the secondary and let it resync.  After that the file-
    system can be mounted and used, and seems to work well.

    I've recently reworked the wait/wakeup/completion logic and apparently introduced a bug
    related to that.

/******************************************************************************/

resource r0 {
    on bottom {
	device	    drbd1;
	disk	    /dev/sda1;
	address	    192.168.1.37:7788;
	meta-disk   internal;
    }
    on blackbox {
	device	    drbd1;
	disk	    /UMCdev/tcmu001;
	address	    192.168.1.9:7788;
	meta-disk   internal;
    }
}

/******************************************************************************/

# /etc/scst.conf
# Comments must start a line (no comments at end of line after commands)
# (This is the ancient format of the SCST config file used with /proc in version 2.6.24)

[OPTIONS]
# Copy configuration options during a -writeconfig
KEEP_CONFIG TRUE
# For FC targets, issue a LIP after every assignment change
ISSUE_LIP FALSE

[HANDLER vdisk]
#DEVICE <vdisk name>,<device path>,<options>,<block size>,<t10 device id>
### DEVICE null_NULLIO,/dev/zero,NULLIO,512,N000
### DEVICE zero_ZERO,/dev/zero,NV_CACHE,512,Z000
### DEVICE zero_BZERO,/dev/zero,BLOCKIO,512,BZ000

######### TCMU DEVICE (unreplicated) #########
# Connection from SCST VDISK through bio_tcmu to a TCMU handler storage backend
#
DEVICE disk_ram000,/UMCdev/tcmu000,BLOCKIO,4096,tcmu000

######### DRBD device (replicated) #########
# Connection from SCST VDISK through bio_tcmu to a DRBD block device
# (The DRBD block device backed (locally) via bio_tcmu to a TCMU handler)
#
# DEVICE disk_drbd1,/UMCdev/drbd1,BLOCKIO|READ_ONLY,4096,drbd1
DEVICE disk_drbd1,/UMCdev/drbd1,BLOCKIO,4096,drbd1

[GROUP Default]

[GROUP blackbox]
USER iqn.1993-08.org.debian:01:42f44c781338

### The "ASSIGNMENT blackbox" statement is giving initiator permissions to blackbox
### itself, because in testing I used blackbox as both Node (U) and as the initiator

[ASSIGNMENT blackbox]
### DEVICE null_NULLIO,0
### DEVICE zero_ZERO,1
### DEVICE zero_BZERO,2
DEVICE disk_ram000,0
DEVICE disk_drbd1,1

### [ASSIGNMENT Default]
### DEVICE disk_sda5,/dev/sda5,,4096,sda5
### DEVICE file_b1,/tmp/disk_b1,NV_CACHE,512,F_b1

[TARGETS enable]
#HOST <wwn identifier>

[TARGETS disable]
#HOST <wwn identifier>

/******************************************************************************/

# /etc/iscsi-scstd.conf

Target iqn.2001-04.com.example.blackbox:1
	QueuedCommands 2048
	RspTimeout 90
	NOPInInterval 30
	NOPInTimeout 30
	MaxSessions 0
	InitialR2T No
	ImmediateData Yes
	MaxConnections 1
	MaxRecvDataSegmentLength 16773120
	MaxXmitDataSegmentLength 16773120
	MaxBurstLength 16773120
	FirstBurstLength 16773120
	DefaultTime2Wait 0
	DefaultTime2Retain 0
	MaxOutstandingR2T 8
	DataPDUInOrder Yes
	DataSequenceInOrder Yes
	ErrorRecoveryLevel 0
	HeaderDigest None
	DataDigest None

/******************************************************************************/

Need some build instructions here.  The process is rather a mess at the moment.  It isn't as
automatic as it ought to be, so you'll likely have to actually read what's below.

Also, some Makefiles require various build tools which I installed one by one as it complained
about not having them.  These are some of them:
    libfuse-dev  libaio-dev  autoconf  flex  exuberant-ctags  cscope

The good news is that I've carried out this entire build sequence in a directory *on* a
replicated device implemented by DRBD running in usermode, and got a runnable binary server.

I have only run the usermode server on machines without DRBD installed in the kernel.
The description below assumes that there are no DRBD modules or utilities installed.
(That would likely be very confusing, though it might work if assigned separate ports)

    NOTE:  The script SCST-Usermode-Adaptation/usermode/BUILD.sh
	   does much of the what is described below.

Make a git directory and clone these repositories into it from github:
    mkdir ~/git
    cd ~/git
    git clone https://github.com/DavidButterfield/MTE.git
    git clone https://github.com/DavidButterfield/usermode_compat.git
    git clone https://github.com/DavidButterfield/SCST-Usermode-Adaptation.git
    git clone https://github.com/DavidButterfield/drbd-9.0.git
    git clone https://github.com/DavidButterfield/drbd-utils.git

Checkout the right branches:
    MTE				master		# should be default
    usermode_compat		drbd
    SCST-Usermode-Adaptation	drbd
    drbd-9.0			usermode	# should be default
    drbd-utils			usermode	# should be default

Also get linux-2.6.32.27 (only need the kernel headers) into the same "git" directory.
    wget https://cdn.kernel.org/pub/linux/kernel/v2.6/linux-2.6.32.27.tar.gz
    gunzip linux-2.6.32.27.tar.gz
    tar xvf linux-2.6.32.27.tar
    rm linux-2.6.32.27.tar	    # for space if FS is only 1GB

In the drbd-utils source directory:
    ./autogen.sh

    ## Build the drbd utilities "--with-build-usermode" to control a usermode DRBD server.
    ## If you omit --without-manual, it will take a long time for the make to complete.
    ./configure --prefix=/usr --localstatedir=/var --sysconfdir=/etc \
					    --with-build-usermode --without-manual
    make
    sudo make install

In the drbd-9.0 source directory:
    ## NOTE: if you do a "make" in drbd-9,0, it may create a file drbd/compat.h which
    ##	     ***MUST BE DELETED*** before the usermode compile will succeed.
    ##
    ## You should not need to "make" in the drbd-9.0 directory (that might try to make a
    ## version that expects to interact with the kernel).  The make for usermode DRBD is
    ## done from SCST-Usermode-Adaptation/usermode/Makefile passing in the appropriate
    ## flags to drbd-9.0/drbd/Makefile.usermode
    ## 
    ## However, it is necessary to download some headers and compatibility code external
    ## to the drbd-9.0 repository:
    make check-submods

    ## After that additional code gets downloaded, there is a (temporary workaround) patch
    ## that has to be applied to it:
    cd drbd/drbd-kernel-compat
    patch -p1 < ../../PATCH.drbd-kernel-compat

For now SCST has to use emulated /proc (not /sys).  This is enabled by:
    cd SCST-Usermode-Adaptation
    make enable_proc

Install the usermode version of scstadmin and SCST.pm (this must be done AFTER running the
"make enable_proc" above):
    cd SCST-Usermode-Adaptation
    sudo make scstadm
    sudo make scstadm_install

If everything is right, it should now successfully build in SCST-Usermode-Adaptation/usermode.
BUT... the dependencies are not computed correctly in the Makefiles, so for now I always do a
clean make:
    cd SCST-Usermode-Adaptation/usermode
    make clean
    make

That should produce the SCST/DRBD usermode server as scst.out.  There should be no compile
errors, but there will be a few warnings; these can be ignored for now:
    #warning "BDI_CAP_STABLE_WRITES not available"
    #warning In the PROCFS build EXTENDED COPY not supported
    Using 'getaddrinfo' in statically linked apps requires at runtime the shared libraries...
    Using 'dlopen' in statically linked apps requires at runtime the shared libraries...
    "pr_fmt" redefined
    comparison of distinct pointer types lacks a cast
	[because parts of the code think uint64_t is long and other parts long long]

By default the binary is built statically so that addr2line works right for stacktraces.

But for some reason the static binary from gcc (version 8.3.0) makes valgrind think a
lot of memory is uninitialized, so to run under valgrind I change usermode/Makefile in
SCST-Usermode-Adaptation to build non-statically, in addition to enabling -DVALGRIND.

Configuration files:
    The example SCST config files shown above are from Node (U) in my setup.  They will
    have to be modified to suit your configuration, and put into /etc/iscsi-scstd.conf
    and /etc/scst.conf.  The DRBD config for the resource is also shown above and goes
    somewhere in /etc/drbd.d such as /etc/drbd.d/r0.res

SCST needs these directories created:
    sudo mkdir -p /var/lib/scst/pr
    sudo mkdir -p /var/lib/scst/vdev_mode_pages

Create the ramdisk backing files (names currently hardcoded in bio_tcmu.c):
    ## You can make them bigger, but remember the full resync every server restart
    dd if=/dev/zero of=/tmp/cfg1 bs=4096 count=262144	# 1 GiB (unreplicated)
    dd if=/dev/zero of=/tmp/cfg2 bs=4096 count=262144	# 1 GiB (replicated)

To RUN the DRBD utilities so that the scripts refer to the simulated /proc that talks to the
usermode server process (rather than the real /proc that talks to kernel), ***SET ENVIRONMENT***
    export PROC_PREFIX=/fuse/scst
