Sun 07 Jul 2019 03:26:27 PM MDT
    This is an early runnable version of usermode SCST/DRBD.

    The drbd source code is (nearly) unmodified, with its expected kernel environment simulated
    around it.  For more information about how that was done, see the README.md shown at
    https://github.com/DavidButterfield/SCST-Usermode-Adaptation

    Build information at the end below.

Demo config:
    I set up a small DRBD device of 1 GB, internal metadata, with ext4 filesystem

    One Node (K) running standard DRBD 9.0 in the kernel (exposing /dev/drbd1)
	DRBD's backing device is a partition on a real disk /dev/sda1
	Replicated device can be mounted as /dev/drbd1 (when primary)

    One Node (U) running DRBD 9.0 in USERMODE in a process with SCST (dev_t internal only)
	DRBD's backing device is a block device implemented as a 1 GB ramdisk
	The ramdisk is an mmap(2) backed by a 1 GB file /tmp/cfg2
	Replicated DRBD device is plumbed underneath SCST as an SCST vdisk backing bdev
	SCST exposes the volume as a SCSI device through iSCSI

    An iSCSI initiator with a session to Node (U)
	When Node U is primary, iSCSI initiator can mount the replicated filesystem
	Exposes the SCSI device as a block device, mountable as /dev/sdj (on my initiator).
	(For most testing I happened to use Node (U) also as the iSCSI initiator)

    I've written bio_tcmu to connect a bio request to a tcmu-runner storage backend handler.
    TCMU itself is not involved -- I'm just repurposing their backend handlers by translating
    bio requests from DRBD or SCST into the protocol expected by the existing TCMU handlers.

    There are several TCMU handlers for different usermode storage providers such as ceph, qemu,
    and gluster; I've written a simple one for an mmap(2) ramdisk, used here.  I also have
    started a prototype of a handler for SPDK, which interfaces through bio_tcmu from the same
    place occupied by tcmu_ram in this diagram.

                            iSCSI
  /dev/sdj ---> Initiator <=======> SCST-iSCSI 
                                        |
                                    SCST-core                                   [Node U]
                                        |        bio          bio
                                    SCST-vdisk <=====> DRBD <=====> bio_tcmu
                                                        ^               |     mmap
                                                        |           tcmu_ram <====> /tmp/cfg2
                                                        |1GbE
                                                        |
                                                        |
                                                        v     bio
                                       /dev/drbd1 ---> DRBD <=====> sda1        [Node K]

    It is also possible to plumb SCST-vdisk directly to bio_tcmu through the bio interface,
    bypassing DRBD (in that case the exposed LUN is unreplicated, of course).

    A sample scst.conf file below defines the following two SCST device instances, one connected
    as shown above, the other a direct connection SCST to the TCMU ram module as just mentioned.

                    initiator   SCST    Replicated device   Unreplicated device     backing file
                    ----------  -----   ----------------------------------------    ------------
    (unreplicated)  /dev/sdi    LUN 0                       /UMCfuse/dev/tcmu000    /tmp/cfg1
    (replicated)    /dev/sdj    LUN 1   /UMCfuse/dev/drbd1  /UMCfuse/dev/tcmu001    /tmp/cfg2
					(The /tmp/cfg names are currently hardcoded in bio_tcmu.c)

    Finally, it is also now possible to access and mount a DRBD or tcmu_runner block device
    through a fuse node that issues bio requests (not shown in diagram).  (This does not make
    use of the iSCSI initiator or SCST)
	sudo mount /UMCfuse/dev/drbd1	/mnt/i		# replicated device
	sudo mount /UMCfuse/dev/tcmu000 /mnt/j		# unreplicated device

Demo capabilities -- with this config I was able to do the following:

    Monitor network traffic between Nodes (U) and (K) using tcpdump
    Establish DRBD replication connection between Nodes (U) and (K)

    On Node (U):
	drbdsetup primary r0
	scstadmin -config /etc/scst.conf    # configure SCST

    On iSCSI initiator machine:
	iSCSI login to node (U) (exposes /dev/sdj on my initiator)
	mkfs.ext4 /dev/sdj
	mount /dev/sdj /mnt/j ; mkdir /mnt/j/git ; cd /mnt/j/git 
	Download source repositories from github directly onto the replicated device
	Run "make" and successfully build the usermode binary with Node (U) primary
	    while observing replication traffic in tcpdump during the build
	cd / ; umount /mnt/j
	iSCSI logout from Node (U)  # causes SCST to close the DRBD device

    Set node (U) as secondary:
	drbdsetup secondary r0	    # should succeed after iSCSI logout

    On Node (K):
	drbdsetup primary r0
	mount /dev/drbd1 /mnt/j
	Observe the built binary from the make done on Node (U)
	Save a copy of the binary built on Node (U)
	Run "make clean" and "make" to do the successful build again on Node (K)
	    while observing replication traffic in tcpdump during the build
	Strip the two binaries and they compare equal except 20 bytes probably timestamp
	cd / ; umount /mnt/j
	drbdsetup secondary r0

    On Node (U):
	drbdsetup primary r0
	scstadmin -config /etc/scst.conf    # configure SCST

    On iSCSI initiator machine:
	iSCSI login to node (U)
	mount /dev/sdj /mnt/j
	Copy the binary built on Node (U) onto a local disk of node (U)
	Restart the server on Node (U), running the executable built on the replicated device

    In a separate configuration I ran two usermode SCST/DRBD servers on two machines
    doing the same sort of replication as above (but not using any kernel-based DRBD).

    I've also carried out the full download/build process on a locally-mounted DRBD device
    through fuse.

Limitations:
    Netlink multicast emulation not yet implemented, so anything like "drbdsetup wait*" hangs.

    Many things are hacked just enough to get it to work, and neglecting performance.
    The makefiles have optimizations turned off and debugs turned on.  But not taking any
    measurements, the performance of a DRBD replicated device through iSCSI and SCST feels
    more-or-less like normal, watching my makes run.  (They do have the significant advantage
    of running on a ramdisk).

    The server-internal block device nodes are exposed through the fuse filesystem mount.  The
    fuse-tree node that represents a drbd or tcmu block device appears as a regular file rather
    than as a block device (because otherwise fuse directs I/O for that dev_t to the kernel
    instead of the fuse filesystem server).  So when communicating with a usermode server, the
    DRBD utilities omit the check that their device is S_IFBLK() rather than S_IFREG().

    Resync may run noticeably slower when observing resync network traffic with tcpdump.

    Something I expect NOT to work is running the server executable off of a disk it implements.

Bugs:
    Clean shutdown via SIGINT (CTRL-C) still has a couple of unfreed memory allocations:
	"fifo" leak at drbd_sender.c:552    (DRBD)
	"iSCSI AEN" leak at iscsi.c:1048    (UMC)

    Sometimes resync doesn't start upon reconnect after restarting the usermode server.
    It doesn't seem to happen as much when running tcpdump to observe the inter-peer traffic.
    If it doesn't start, disconnecting + reconnecting to the peer usually gets it going.

    Also sometimes mkfs.ext4 on a replicated device hangs near the end of the mkfs.  I've
    seen something similar with fsck.ext4 in cases when it needs to update the filesystem.
    Disconnecting + reconnecting the peer allows the mkfs to finish.

    Nested spinlocks aren't implemented, so that occasional lock point locks only the
    resources_mutex, but does not loop through and acquire all the spinlocks like it should.

    "Exclusive" opens aren't really exclusive, so be careful not to mount the same storage
    twice; for example /UMCfuse/dev/tcmu001 and /UMCfuse/dev/drbd1 are the same storage.

Sample configuration files
################################################################################
# /etc/drbd.d/r0.res

resource r0 {
    on blackbox {
	node-id			0;
	address			172.28.128.1:7788;
	volume 0 {
	    device		drbd1 minor 1;
	    disk		"/UMCfuse/dev/tcmu001";
	    meta-disk		internal;
	}
    }

    on vagrant {
	node-id			1;
	address			172.28.128.3:7788;
	volume 0 {
	    device		drbd1 minor 1;
            disk		"/UMCfuse/dev/tcmu001";
	    meta-disk		internal;
	 }
    }

    disk {
	# Put the "c-plan-ahead 0" line first or the others will be silently ignored
	c-plan-ahead		0;			# do not use plan-ahead algorithm
	resync-rate		40000K;			# max bytes/second for resync
	c-min-rate		0k;			# min bytes/second for app
    }
}

################################################################################
# /etc/scst.conf
# Comments must start a line (no comments at end of line after commands)
# (This is the ancient format of the SCST config file used with /proc in version 2.6.24)

[OPTIONS]
KEEP_CONFIG TRUE
ISSUE_LIP FALSE

[HANDLER vdisk]
#DEVICE <vdisk name>,<device path>,<options>,<block size>,<t10 device id>

# Connection from SCST VDISK through bio_tcmu to a TCMU handler storage backend
DEVICE disk_ram000,/UMCfuse/dev/tcmu000,BLOCKIO,4096,tcmu000

# Connection from SCST VDISK through bio_tcmu to a DRBD block device
DEVICE disk_drbd1,/UMCfuse/dev/drbd1,BLOCKIO,4096,drbd1

[GROUP Default]

### The appearance of blackbox in the initiator assignments is due to using blackbox both
### as Node (U) and as an initiator to itself (iSCSI login from blackbox to blackbox).

[GROUP blackbox]
USER iqn.1993-08.org.debian:01:42f44c781338

[ASSIGNMENT blackbox]
DEVICE disk_ram000,0
DEVICE disk_drbd1,1

[TARGETS enable]
#HOST <wwn identifier>

[TARGETS disable]
#HOST <wwn identifier>

################################################################################
# /etc/iscsi-scstd.conf

Target iqn.2001-04.com.example.blackbox:1
	QueuedCommands 2048
	RspTimeout 90
	NOPInInterval 30
	NOPInTimeout 30
	MaxSessions 0
	InitialR2T No
	ImmediateData Yes
	MaxConnections 1
	MaxRecvDataSegmentLength 16773120
	MaxXmitDataSegmentLength 16773120
	MaxBurstLength 16773120
	FirstBurstLength 16773120
	DefaultTime2Wait 0
	DefaultTime2Retain 0
	MaxOutstandingR2T 8
	DataPDUInOrder Yes
	DataSequenceInOrder Yes
	ErrorRecoveryLevel 0
	HeaderDigest None
	DataDigest None

################################################################################

Need some build instructions here.  The process is rather a mess at the moment.  It isn't as
automatic as it ought to be, so you'll likely have to actually read what's below.  Especially
the last three paragraphs.

Also, some Makefiles require various build tools which I installed one by one as it complained
about not having them.  These are some of them:
    libfuse-dev  libaio-dev  autoconf  flex  exuberant-ctags  cscope

I have only run the usermode server on machines without DRBD installed in the kernel.
The description below assumes that there are no DRBD modules or utilities installed.
(That would likely be very confusing, though it might work if assigned separate ports)

    NOTE:  The script SCST-Usermode-Adaptation/usermode/BUILD.sh
	   does much of the what is described below.

Make a git directory and clone these repositories into it:
    mkdir git
    cd git
    git clone https://github.com/DavidButterfield/MTE.git
    git clone https://github.com/DavidButterfield/usermode_compat.git
    git clone https://github.com/DavidButterfield/SCST-Usermode-Adaptation.git
    git clone https://github.com/DavidButterfield/drbd-9.0.git
    git clone https://github.com/DavidButterfield/drbd-utils.git

Checkout the right branches:
    MTE				master		# should be default
    usermode_compat		drbd
    SCST-Usermode-Adaptation	drbd
    drbd-9.0			usermode	# should be default
    drbd-utils			usermode	# should be default

Also get linux-2.6.32.27 into the same "git" directory.
    wget https://cdn.kernel.org/pub/linux/kernel/v2.6/linux-2.6.32.27.tar.gz
    gunzip linux-2.6.32.27.tar.gz
    tar xvf linux-2.6.32.27.tar
    rm linux-2.6.32.27.tar	    # for space if FS is only 1GB

In the drbd-utils source directory:
    ./autogen.sh

    ## If you omit --without-manual, it will take a long time for the make to complete.
    ./configure --prefix=/usr --localstatedir=/var --sysconfdir=/etc --without-manual
    make
    sudo make install

In the drbd-9.0 source directory:
    ## NOTE: if you do a "make" in drbd-9.0, it may create a file drbd/compat.h which
    ##	     ***MUST BE DELETED*** before the usermode compile will succeed.
    ##
    ## You should not need to "make" in the drbd-9.0 directory.  The make for usermode DRBD is
    ## done from SCST-Usermode-Adaptation/usermode/Makefile passing in the appropriate flags
    ## to drbd-9.0/drbd/Makefile.usermode
    ## 
    ## However, it is necessary to download some headers and compatibility code external
    ## to the drbd-9.0 repository:
    make check-submods

    ## After that additional code gets downloaded, there is a patch to apply to it:
    cd drbd/drbd-kernel-compat
    patch -p1 < ../../PATCH.drbd-kernel-compat

For now SCST has to use emulated /proc (not /sys).  This is enabled by:
    cd SCST-Usermode-Adaptation
    make enable_proc

Install the usermode version of scstadmin and SCST.pm (this must be done AFTER running the
"make enable_proc" above):
    cd SCST-Usermode-Adaptation
    sudo make scstadm
    sudo make scstadm_install

If everything is right, it should now successfully build in SCST-Usermode-Adaptation/usermode.
BUT... the dependencies are not computed correctly in the Makefiles, so for now I always do a
clean make:
    cd SCST-Usermode-Adaptation/usermode
    make clean
    make

That should produce the SCST/DRBD usermode server as scst.out.  There should be no compile
errors, but there will be a few warnings; these can be ignored for now:
    #warning "BDI_CAP_STABLE_WRITES not available"
    #warning In the PROCFS build EXTENDED COPY not supported
    Using 'getaddrinfo' in statically linked apps requires at runtime the shared libraries...
    Using 'dlopen' in statically linked apps requires at runtime the shared libraries...
    "pr_fmt" redefined
    "arch_wb_cache_pmem" redefined
    comparison of distinct pointer types lacks a cast
	[because parts of the code think uint64_t is long and other parts long long]

By default the binary is built statically so that addr2line works right for stacktraces.

But for some reason the static binary from gcc (version 8.3.0) makes valgrind think a
lot of memory is uninitialized, so to run under valgrind I change usermode/Makefile in
SCST-Usermode-Adaptation to build non-statically, in addition to enabling -DVALGRIND.

Configuration files:
    The example config files shown above are from Node (U) in my setup.  They will have to be
    modified to suit your network configuration, and put into /etc/iscsi-scstd.conf,
    /etc/scst.conf, and somewhere in /etc/drbd.d such as /etc/drbd.d/r0.res

SCST needs these directories created:
    sudo mkdir -p /var/lib/scst/pr
    sudo mkdir -p /var/lib/scst/vdev_mode_pages

Create the ramdisk backing files (names currently hardcoded in bio_tcmu.c):
    ## You can make them bigger if you want -- 1 GiB can download and build the server
    dd if=/dev/zero of=/tmp/cfg1 bs=4096 count=262144	# 1 GiB (unreplicated)
    dd if=/dev/zero of=/tmp/cfg2 bs=4096 count=262144	# 1 GiB (replicated)

To RUN the DRBD utilities so that the scripts refer to the simulated /proc that talks to the
usermode server process (rather than the real /proc that talks to kernel), ***SET ENVIRONMENT***
    export UMC_FS_ROOT=/UMCfuse

The utilities need the UMC_FS_ROOT environment variable set to control the usermode DRBD server
instead of a kernel-based server.  But they also need to run superuser.  Keep in mind that the
sudo program does not pass your shell environment through to the program given on its command
line, unless you specify "sudo -E".  

Start the usermode SCST/DRBD server:
    export UMC_FS_ROOT=/UMCfuse
    sudo ./scst.out -f
    sudo -E drbdadm up r0
    sudo -E drbdsetup primary r0

Either export the replicated device as a LUN through SCST:
    scstadmin -config /etc/scst.conf

Or use the replicated device through its fuse node, e.g.
    sudo mkfs.ext4 /UMCfuse/dev/drbd1
    sudo mount /UMCfuse/dev/drbd1 /mnt/i
